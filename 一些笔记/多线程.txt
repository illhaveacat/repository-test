1、sleep 和wait 的区别
	sleep不会释放锁，wait会释放当前锁
	
2、sleep和sleep(0)的区别
	sleep(0)：如果线程调度器的可运行队列中有大于当前线程优先级的就绪线程存在，
	操作系统会将当前线程从处理器上移除，调度其它优先级高的就绪线程运行；如果
	没有其他的可运行线程或者就绪线程的优先级均低于当前线程优先级，那么当前线程
	会继续运行，就像没有调用sleep(0)一样。
	
	sleep(1):调用线程会从线程调度器的可运行队列中被移除一段时间,通常情况下，
	系统的时间精度为 10 ms，那么指定任意少于 10 ms
	但大于 0 ms 的睡眠时间，均会向上求值为 10 ms。
	
3、ThreadPoolExecutor有哪些配置项？
	corePoolSize:核心池大小
	maximumPoolSize:最大线程数
	keepAliveTime:线程没有任务执行时，最多保持多长时间会终止，然后维持corePoolSize大小
	unit：keepAliveTime的时间单位
	workQueue:阻塞队列
	threadFactory:线程工厂，主要用来创建线程，比如可以指定线程的名字
	handler：如果线程池已满，新的任务的处理方式
	
4、什么是线程安全
    不可变


5、Synchronized同步静态方法和非静态方法总结

对象锁：
	1)两个线程分别访问对象的两个非静态同步方式，会产生互斥，必须等待上一个线程释放锁
	2)两个线程在类的不同对象调用同一个非静态同步方法,不会产生互斥,因为是两个对象，两把锁

类锁：
	1)两个线程分别调用类的两个不同的静态同步方法,会互斥，类锁只有一个
	2)两个线程使用类的静态对象调用静态同步方法或非静态同步方法，不会互斥 因为是两把不一样的锁
	3两个线程使用一个对象调用静态同步方法或非静态同步方法，不会互斥，因为是两把不一样的锁


6、java四大并发工具类：阻塞队列、信号量(Semaphore)、栅栏(Barrier)、闭锁(Latch)
	CyclicBarrier：等待最后一个线程到达栅栏（屏障），然后执行后续任务
	
	
	